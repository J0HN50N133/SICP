** 2.4节笔记
从对复数的多种表示方式入手（对应实践中对一个事物可以有多种建模），首先引入了if-else的做法，然后引入了数据驱动的思想。
两种方法写出来的代码具体区别如下：
- if-else法：
  处理数据的函数就是一个cond子句（在C系语法中对应多个type）处理，一个类型写一个cond子句，来让函数采取对应的处理方法。

  - 这样做的好处：简单粗暴，容易想到
  - 缺点：
    - 不好拓展，每新加一个类型就要加一个cond子句，久而久之处理函数将会变得庞大无比。
    - 随着函数变大，逻辑越来越复杂，函数越来越不好理解。
- 数据驱动法：
  数据驱动的方法就是将每个类型对应的操作单独抽取出来包装成为函数，用一个表结构来记录 *一个类型的某一个操作* 应该对应哪一个函数。我们知道处理函数里
  除了那些类型特定的操作以外，其余部分的逻辑应当是相同的。在《Unix应用编程》里将其称为机制与策略分离。我的理解就是机制是整个系统针对一类数据的处理
逻辑是相同的，比如说复数操作包里不管是rectangular还是polar的加法都是取出实部和虚步以后对应部分各自相加，这一部分称为机制，然后每个类型各自怎么取
实部和虚部就是类型内部自己定义的事情了。
  - 优点
    - 可读性好
    - 容易修改
    - 代码重用性强
SICP中介绍的属于表驱动法。
[[https://blog.csdn.net/chgaowei/article/details/6658260][什么是数据驱动编程（CSDN的C语言解释）]]
** 2.5节笔记
- 本节讲了一个通用操作系统的例子来说明如何在不修改原有代码的情况下，向一个 *定义了一系列操作的系统* 中添加新的模块，并且让新的模块兼容原有的操作。
- 第二部分则讲了系统中现在有多个模块，每个模块自身是支持系统中所有的操作的，
  但模块与模块之间能够进行操作（例如来自复数包的一个复数和来自整数包的一个整数能进行加法吗）吗？要怎么样对这样的操作添加支持呢？
  通过类型转换。类型转换我们也是用数据驱动的思路来进行，类型转换总体处理的逻辑无非是拿到了A类型和B类型的数据，然后查找有没有对应类型的转换函数，
  有则应用，无则返回。
- 每个包内部应当看不到自己的type-tag，type-tag是用来让包外部的世界知道一个数据应该导入哪个包进行操作的，内部的type-tag没有意义。
